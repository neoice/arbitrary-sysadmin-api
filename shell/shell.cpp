// basic shell
// written as an assignment

// assignment header
#include "make_cmd.h"

// stdlib
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>

// syscalls
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// other
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

using namespace std;

// this does all the errno printing for us. it was generated by
// dumping the output of `man errno` into vim and using some regex
// and visual block magic.
// I _highly_ recommend using code-folding to hide it.
void errno_handler(int error_id)
{
	char *error_msg;

	switch (error_id) {
		case(E2BIG          ): error_msg ="Argument list too long"; break;
		case(EACCES         ): error_msg ="Permission denied"; break;
		case(EADDRINUSE     ): error_msg ="Address already in use"; break;
		case(EADDRNOTAVAIL  ): error_msg ="Address not available"; break;
		case(EAFNOSUPPORT   ): error_msg ="Address family not supported"; break;
		case(EAGAIN         ): error_msg ="Resource temporarily unavailable"; break;
		case(EALREADY       ): error_msg ="Connection already in progress"; break;
		case(EBADE          ): error_msg ="Invalid exchange"; break;
		case(EBADF          ): error_msg ="Bad file descriptor"; break;
		case(EBADFD         ): error_msg ="File descriptor in bad state"; break;
		case(EBADMSG        ): error_msg ="Bad message"; break;
		case(EBADR          ): error_msg ="Invalid request descriptor"; break;
		case(EBADRQC        ): error_msg ="Invalid request code"; break;
		case(EBADSLT        ): error_msg ="Invalid slot"; break;
		case(EBUSY          ): error_msg ="Device or resource busy"; break;
		case(ECANCELED      ): error_msg ="Operation canceled"; break;
		case(ECHILD         ): error_msg ="No child processes"; break;
		case(ECHRNG         ): error_msg ="Channel number out of range"; break;
		case(ECOMM          ): error_msg ="Communication error on send"; break;
		case(ECONNABORTED   ): error_msg ="Connection aborted"; break;
		case(ECONNREFUSED   ): error_msg ="Connection refused"; break;
		case(ECONNRESET     ): error_msg ="Connection reset"; break;
		case(EDEADLK        ): error_msg ="Resource deadlock avoided"; break;
		case(EDESTADDRREQ   ): error_msg ="Destination address required"; break;
		case(EDOM           ): error_msg ="Mathematics argument out of domain of function"; break;
		case(EDQUOT         ): error_msg ="Disk quota exceeded"; break;
		case(EEXIST         ): error_msg ="File exists"; break;
		case(EFAULT         ): error_msg ="Bad address"; break;
		case(EFBIG          ): error_msg ="File too large"; break;
		case(EHOSTDOWN      ): error_msg ="Host is down"; break;
		case(EHOSTUNREACH   ): error_msg ="Host is unreachable"; break;
		case(EIDRM          ): error_msg ="Identifier removed"; break;
		case(EILSEQ         ): error_msg ="Illegal byte sequence"; break;
		case(EINPROGRESS    ): error_msg ="Operation in progress"; break;
		case(EINTR          ): error_msg ="Interrupted function call."; break;
		case(EINVAL         ): error_msg ="Invalid argument"; break;
		case(EIO            ): error_msg ="Input/output error"; break;
		case(EISCONN        ): error_msg ="Socket is connected"; break;
		case(EISDIR         ): error_msg ="Is a directory"; break;
		case(EISNAM         ): error_msg ="Is a named type file"; break;
		case(EKEYEXPIRED    ): error_msg ="Key has expired"; break;
		case(EKEYREJECTED   ): error_msg ="Key was rejected by service"; break;
		case(EKEYREVOKED    ): error_msg ="Key has been revoked"; break;
		case(EL2HLT         ): error_msg ="Level 2 halted"; break;
		case(EL2NSYNC       ): error_msg ="Level 2 not synchronize"; break;
		case(EL3HLT         ): error_msg ="Level 3 halted"; break;
		case(EL3RST         ): error_msg ="Level 3 halted"; break;
		case(ELIBACC        ): error_msg ="Cannot access a needed shared library"; break;
		case(ELIBBAD        ): error_msg ="Accessing a corrupted shared library"; break;
		case(ELIBMAX        ): error_msg ="Attempting to link in too many shared libraries"; break;
		case(ELIBSCN        ): error_msg ="lib section in a.out corrupted"; break;
		case(ELIBEXEC       ): error_msg ="Cannot exec a shared library directly"; break;
		case(ELOOP          ): error_msg ="Too many levels of symbolic links"; break;
		case(EMEDIUMTYPE    ): error_msg ="Wrong medium type"; break;
		case(EMFILE         ): error_msg ="Too many open files"; break;
		case(EMLINK         ): error_msg ="Too many links"; break;
		case(EMSGSIZE       ): error_msg ="Message too long"; break;
		case(EMULTIHOP      ): error_msg ="Multihop attempted"; break;
		case(ENAMETOOLONG   ): error_msg ="Filename too long"; break;
		case(ENETDOWN       ): error_msg ="Network is down"; break;
		case(ENETRESET      ): error_msg ="Connection aborted by network"; break;
		case(ENETUNREACH    ): error_msg ="Network unreachable"; break;
		case(ENFILE         ): error_msg ="Too many open files in system"; break;
		case(ENOBUFS        ): error_msg ="No buffer space available"; break;
		case(ENODATA        ): error_msg ="No message is available on the STREAM head read queue"; break;
		case(ENODEV         ): error_msg ="No such device"; break;
		case(ENOENT         ): error_msg ="No such file or directory"; break;
		case(ENOEXEC        ): error_msg ="Exec format error"; break;
		case(ENOKEY         ): error_msg ="Required key not available"; break;
		case(ENOLCK         ): error_msg ="No locks available"; break;
		case(ENOLINK        ): error_msg ="Link has been severed"; break;
		case(ENOMEDIUM      ): error_msg ="No medium found"; break;
		case(ENOMEM         ): error_msg ="Not enough space"; break;
		case(ENOMSG         ): error_msg ="No message of the desired type"; break;
		case(ENONET         ): error_msg ="Machine is not on the network"; break;
		case(ENOPKG         ): error_msg ="Package not installed"; break;
		case(ENOPROTOOPT    ): error_msg ="Protocol not available"; break;
		case(ENOSPC         ): error_msg ="No space left on device"; break;
		case(ENOSR          ): error_msg ="No STREAM resources"; break;
		case(ENOSTR         ): error_msg ="Not a STREAM"; break;
		case(ENOSYS         ): error_msg ="Function not implemented"; break;
		case(ENOTBLK        ): error_msg ="Block device required"; break;
		case(ENOTCONN       ): error_msg ="The socket is not connected"; break;
		case(ENOTDIR        ): error_msg ="Not a directory"; break;
		case(ENOTEMPTY      ): error_msg ="Directory not empty"; break;
		case(ENOTSOCK       ): error_msg ="Not a socket"; break;
		case(ENOTSUP        ): error_msg ="Operation not supported"; break;
		case(ENOTTY         ): error_msg ="Inappropriate I/O control operation"; break;
		case(ENOTUNIQ       ): error_msg ="Name not unique on network"; break;
		case(ENXIO          ): error_msg ="No such device or address"; break;
		case(EOVERFLOW      ): error_msg ="Value too large to be stored in data type"; break;
		case(EPERM          ): error_msg ="Operation not permitted"; break;
		case(EPFNOSUPPORT   ): error_msg ="Protocol family not supported"; break;
		case(EPIPE          ): error_msg ="Broken pipe"; break;
		case(EPROTO         ): error_msg ="Protocol error"; break;
		case(EPROTONOSUPPORT): error_msg ="Protocol not supported"; break;
		case(EPROTOTYPE     ): error_msg ="Protocol wrong type for socket"; break;
		case(ERANGE         ): error_msg ="Result too large"; break;
		case(EREMCHG        ): error_msg ="Remote address changed"; break;
		case(EREMOTE        ): error_msg ="Object is remote"; break;
		case(EREMOTEIO      ): error_msg ="Remote I/O error"; break;
		case(ERESTART       ): error_msg ="Interrupted system call should be restarted"; break;
		case(EROFS          ): error_msg ="Read-only file system"; break;
		case(ESHUTDOWN      ): error_msg ="Cannot send after transport endpoint shutdown"; break;
		case(ESPIPE         ): error_msg ="Invalid seek"; break;
		case(ESOCKTNOSUPPORT): error_msg ="Socket type not supported"; break;
		case(ESRCH          ): error_msg ="No such process"; break;
		case(ESTALE         ): error_msg ="Stale file handle"; break;
		case(ESTRPIPE       ): error_msg ="Streams pipe error"; break;
		case(ETIME          ): error_msg ="Timer expired"; break;
		case(ETIMEDOUT      ): error_msg ="Connection timed out"; break;
		case(ETXTBSY        ): error_msg ="Text file busy"; break;
		case(EUCLEAN        ): error_msg ="Structure needs cleaning"; break;
		case(EUNATCH        ): error_msg ="Protocol driver not attached"; break;
		case(EUSERS         ): error_msg ="Too many users"; break;
		case(EXDEV          ): error_msg ="Improper link"; break;
		case(EXFULL         ): error_msg ="Exchange full"; break;
	}

	printf("%s\n", error_msg);

	return;
}

int main(void)
{
	// data
	char raw[511];		// raw string input
	cmd_t clean;		// cleaned command object
	int argc;		// holds arg count returned from make_cmd
	bool logging = false;	// log enabled?

	int exec_status;	// did exec() work?
	int ret = 0;		// return value of executed command
	pid_t pid;		// PID of executed command

	fstream histfile;
	int fd;			// file descriptor for redirects

	// display prompt and enter our input loop.
	// I actually do a lot of development that requires knowing
	// return values so we will include this as part of the prompt.
	printf("%3i %% ", ret);
	while ( cin.getline(raw,511) ) {
		argc = make_cmd(raw, clean);

		// we have correctly cleaned our data (raw) and have a struct (clean)
		// any failures in the cleaning are undocumented and will be ignored.
		if (argc > 0) {
			// quit
			if ( ! strcmp(clean.argv[0], "quit") ) {
				return 0;
			}

			// log open
			if ( ! strcmp(clean.argv[0], "startlog") ) {
				if (logging) {
					printf("you already have a logfile open!\n");
					// duplicated code, lame
					printf("%3i %% ", ret);	// reprompt
					ret = 0;		// zero out the return
					continue;
				}
				histfile.open(clean.argv[1], fstream::out);

				if ( histfile.is_open() ) {
					printf("opening logfile %s\n", clean.argv[1]);
					logging = true;
				}
				else {
					printf("opening logfile failed.\n");
					histfile.close();
				}

				// duplicated code, lame
				printf("%3i %% ", ret);	// reprompt
				ret = 0;		// zero out the return
				continue;
			}

			// log close
			if ( ! strcmp(clean.argv[0], "endlog") ) {
				histfile.close();
				logging = false;

				// duplicated code, lame
				printf("%3i %% ", ret);	// reprompt
				ret = 0;		// zero out the return
				continue;
			}

			// log write
			if (logging) {
				histfile << clean.argv[0] << " ";
				for (int i = 1; i < argc; i++) {
					histfile << clean.argv[i] << " ";
				}
				histfile << endl;
			}

			// ENGAGE: this section handles the following:
			//	1) open and read file input
			//	2) open and write file output
			//	3) fork a child and run that exec()
			if( (pid = fork()) == 0) {
				// 1) file input
				if (clean.input_redirect) {
					if ( (fd = open(clean.input_redirect, O_RDONLY)) == -1 ) {
						// do error
					}
					dup2(fd, STDIN_FILENO);
					dup2(STDIN_FILENO,fd);
				}

				// 2) file output
				if (clean.output_redirect) {
					if ( (fd = open(clean.output_redirect, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1 ) {
						// do error
					}
					dup2(fd, STDOUT_FILENO);
					dup2(STDOUT_FILENO,fd);
				}

				// 3) fork() && exec()
				if (clean.background) {
					exec_status = execvp(clean.argv[0], clean.argv);
				}
				else {
					exec_status = execvp(clean.argv[0], clean.argv);
				}

				if (exec_status != 0) {
					errno_handler(errno);
					return errno;
				}

				// clean up
				close(fd);
			}
			else {
				if (clean.background) {
					printf("process %i backgrounded.\n", pid);

					// duplicated code, lame
					printf("%3i %% ", ret);	// reprompt
					ret = 0;		// zero out the return
					continue;
				}
				else {
					waitpid(pid, &ret, 0);	// capture the return value of the child
					ret = ret / 256;	// and convert it to traditional 0-255
				}
			}
		}

		printf("%3i %% ", ret);	// reprompt
		ret = 0;		// zero out the return
	}

	return 0;
}
